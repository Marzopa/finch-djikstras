<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="/KOM+Dta?!4%aSWGw-i}" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="h|kyJJ)Pae*C,tj)Gj6G"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace finchDijkstra {" line1="" line2="    // ----------------------------------------------" line3="    // Global Variables" line4="    // ----------------------------------------------" line5="    let grid: number[][] = []" line6="    let path: string[] = [] // we'll store a path as [&quot;row,col&quot;, &quot;row,col&quot;, ...]" line7="" line8="    // Stubs: replace with real Finch calls" line9="    function moveForward(): void {" line10="        finch.setMove(MoveDir.Forward, 15, 100)" line11="        console.log(&quot;Moving forward 1 cell&quot;)" line12="    }" line13="    function turnLeft(): void {" line14="        finch.setTurn(RLDir.Left, 90, 100)" line15="        console.log(&quot;Turning left 90 degrees&quot;)" line16="    }" line17="    function turnRight(): void {" line18="        finch.setTurn(RLDir.Right, 90, 100)" line19="        console.log(&quot;Turning right 90 degrees&quot;)" line20="    }" line21="" line22="    // ----------------------------------------------" line23="    // BLOCK 1: Initialize the Grid" line24="    // ----------------------------------------------" line25="    //% blockId=&quot;FD_initGrid&quot; block=&quot;Initialize the grid&quot;" line26="    export function initGrid(): void {" line27="        // Example grid with 7 rows and 9 columns" line28="        // 0 = open, 9 = barrier" line29="        grid = [" line30="            [0, 0, 0, 9, 0, 0, 0, 0, 0]," line31="            [0, 9, 0, 9, 0, 9, 0, 0, 0]," line32="            [0, 9, 0, 9, 0, 9, 0, 0, 0]," line33="            [0, 9, 0, 9, 0, 9, 0, 0, 0]," line34="            [0, 9, 0, 0, 0, 9, 0, 0, 0]," line35="            [0, 9, 9, 9, 9, 9, 0, 0, 0]," line36="            [0, 0, 0, 0, 0, 0, 0, 0, 0]" line37="        ]" line38="        path = [] // reset" line39="        console.log(&quot;Grid initialized&quot;)" line40="    }" line41="" line42="    // ----------------------------------------------" line43="    // Helper Functions for BFS" line44="    // ----------------------------------------------" line45="    function posToString(r: number, c: number): string {" line46="        return r + &quot;,&quot; + c" line47="    }" line48="    function stringToPos(pos: string): [number, number] {" line49="        let parts = pos.split(&quot;,&quot;)" line50="        let rr = parseInt(parts[0])" line51="        let cc = parseInt(parts[1])" line52="        return [rr, cc]" line53="    }" line54="" line55="    // 4 directions: up, down, left, right" line56="    let directions = [" line57="        [-1, 0]," line58="        [1, 0]," line59="        [0, -1]," line60="        [0, 1]" line61="    ]" line62="" line63="    // ----------------------------------------------" line64="    // BLOCK 2: Compute BFS Path" line65="    // ----------------------------------------------" line66="    //% blockId=&quot;FD_computePath&quot; block=&quot;Compute path from row $startR col $startC to row $endR col $endC&quot;" line67="    export function computePath(startR: number, startC: number, endR: number, endC: number): void {" line68="        let rows = grid.length" line69="        if (rows === 0) {" line70="            console.log(&quot;Grid is empty, call initGrid first&quot;)" line71="            return" line72="        }" line73="        let cols = grid[0].length" line74="" line75="        // visited array" line76="        let visited: boolean[][] = []" line77="        for (let i = 0; i &lt; rows; i++) {" line78="            visited.push([])" line79="            for (let j = 0; j &lt; cols; j++) {" line80="                visited[i][j] = false" line81="            }" line82="        }" line83="" line84="        // cameFrom to reconstruct the path" line85="        let cameFrom: { [key: string]: string } = {}" line86="" line87="        // BFS queue using two pointers (no shift usage)" line88="        let queue: string[] = []" line89="        let front = 0 // index of next item" line90="" line91="        // Start" line92="        let startPos = posToString(startR, startC)" line93="        queue.push(startPos)" line94="        visited[startR][startC] = true" line95="" line96="        let found = false" line97="        while (front &lt; queue.length) {" line98="            let currentPosStr = queue[front]" line99="            front++" line100="            let currentRC = stringToPos(currentPosStr)" line101="            let cr = currentRC[0]" line102="            let cc2 = currentRC[1]" line103="" line104="            // Check if we've reached the end" line105="            if (cr === endR &amp;&amp; cc2 === endC) {" line106="                found = true" line107="                break" line108="            }" line109="" line110="            // Explore neighbors" line111="            for (let d = 0; d &lt; directions.length; d++) {" line112="                let rr2 = cr + directions[d][0]" line113="                let cc22 = cc2 + directions[d][1]" line114="                if (rr2 &gt;= 0 &amp;&amp; rr2 &lt; rows &amp;&amp; cc22 &gt;= 0 &amp;&amp; cc22 &lt; cols) {" line115="                    if (grid[rr2][cc22] !== 9 &amp;&amp; !visited[rr2][cc22]) {" line116="                        visited[rr2][cc22] = true" line117="                        let neighborStr = posToString(rr2, cc22)" line118="                        cameFrom[neighborStr] = currentPosStr" line119="                        queue.push(neighborStr)" line120="                    }" line121="                }" line122="            }" line123="        }" line124="" line125="        // Reconstruct path if found" line126="        path = []" line127="        if (found) {" line128="            let endPos = posToString(endR, endC)" line129="            let node = endPos" line130="            // Instead of &quot;while (node in cameFrom)&quot;, do a simpler check:" line131="            while (cameFrom[node]) {" line132="                path.push(node)" line133="                node = cameFrom[node]" line134="            }" line135="            // Add start" line136="            path.push(startPos)" line137="            // Reverse" line138="            let reversed: string[] = []" line139="            for (let k = path.length - 1; k &gt;= 0; k--) {" line140="                reversed.push(path[k])" line141="            }" line142="            path = reversed" line143="            console.log(&quot;Path found with BFS. Steps: &quot; + path.length)" line144="        } else {" line145="            console.log(&quot;No path found with BFS.&quot;)" line146="        }" line147="    }" line148="" line149="    // ----------------------------------------------" line150="    // BLOCK 3: Move Robot Along the Path" line151="    // ----------------------------------------------" line152="    //% blockId=&quot;FD_moveRobot&quot; block=&quot;Move robot along path&quot;" line153="    export function moveRobot(): void {" line154="        if (path.length &lt; 2) {" line155="            console.log(&quot;Path is too short or not computed.&quot;)" line156="            return" line157="        }" line158="" line159="        // Start facing &quot;down&quot; for example" line160="        //  (rowDelta, colDelta)" line161="        let currentDir: [number, number] = [1, 0]" line162="" line163="        for (let l = 0; l &lt; path.length - 1; l++) {" line164="            let thisPos = stringToPos(path[l])" line165="            let nextPos = stringToPos(path[l + 1])" line166="" line167="            let moveDir: [number, number] = [" line168="                nextPos[0] - thisPos[0]," line169="                nextPos[1] - thisPos[1]" line170="            ]" line171="" line172="            // If moveDir != currentDir, we turn" line173="            if (moveDir[0] !== currentDir[0] || moveDir[1] !== currentDir[1]) {" line174="                // naive approach to guess left vs right turn" line175="                if (" line176="                    (currentDir[0] === 1 &amp;&amp; moveDir[1] === 1) ||" line177="                    (currentDir[1] === 1 &amp;&amp; moveDir[0] === -1) ||" line178="                    (currentDir[0] === -1 &amp;&amp; moveDir[1] === -1) ||" line179="                    (currentDir[1] === -1 &amp;&amp; moveDir[0] === 1)" line180="                ) {" line181="                    turnRight()" line182="                } else {" line183="                    turnLeft()" line184="                }" line185="                currentDir = moveDir" line186="            }" line187="" line188="            // move forward" line189="            moveForward()" line190="        }" line191="" line192="        console.log(&quot;Path movement complete.&quot;)" line193="    }" line194="}" numlines="195"></mutation></block></statement></block></xml>