<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="62UU~BK*9eG~!e@MRWI{" x="20" y="20"><statement name="HANDLER"><block type="typescript_statement" id="KFaA.T6.y8F}w[Zw$02D"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace finchDijkstra {" line1="" line2="    // ----------------------------------------------" line3="    // Global Variables" line4="    // ----------------------------------------------" line5="    let grid: number[][] = []" line6="    let path: string[] = [] // we'll store a path as [&quot;row,col&quot;, &quot;row,col&quot;, ...]" line7="" line8="    // Stubs: replace with real Finch calls" line9="    function moveForward(): void {" line10="        console.log(&quot;Moving forward 1 cell&quot;)" line11="    }" line12="    function turnLeft(): void {" line13="        console.log(&quot;Turning left 90 degrees&quot;)" line14="    }" line15="    function turnRight(): void {" line16="        console.log(&quot;Turning right 90 degrees&quot;)" line17="    }" line18="" line19="    // ----------------------------------------------" line20="    // BLOCK 1: Initialize the Grid" line21="    // ----------------------------------------------" line22="    //% blockId=&quot;FD_initGrid&quot; block=&quot;Initialize the grid&quot;" line23="    export function initGrid(): void {" line24="        // Example grid with 7 rows and 9 columns" line25="        // 0 = open, 9 = barrier" line26="        grid = [" line27="            [0, 0, 0, 9, 0, 0, 0, 0, 0]," line28="            [0, 9, 0, 9, 0, 9, 0, 0, 0]," line29="            [0, 9, 0, 9, 0, 9, 0, 0, 0]," line30="            [0, 9, 0, 9, 0, 9, 0, 0, 0]," line31="            [0, 9, 0, 0, 0, 9, 0, 0, 0]," line32="            [0, 9, 9, 9, 9, 9, 0, 0, 0]," line33="            [0, 0, 0, 0, 0, 0, 0, 0, 0]" line34="        ]" line35="        path = [] // reset" line36="        console.log(&quot;Grid initialized&quot;)" line37="    }" line38="" line39="    // ----------------------------------------------" line40="    // Helper Functions for BFS" line41="    // ----------------------------------------------" line42="    function posToString(r: number, c: number): string {" line43="        return r + &quot;,&quot; + c" line44="    }" line45="    function stringToPos(pos: string): [number, number] {" line46="        let parts = pos.split(&quot;,&quot;)" line47="        let rr = parseInt(parts[0])" line48="        let cc = parseInt(parts[1])" line49="        return [rr, cc]" line50="    }" line51="" line52="    // 4 directions: up, down, left, right" line53="    let directions = [" line54="        [-1, 0]," line55="        [1, 0]," line56="        [0, -1]," line57="        [0, 1]" line58="    ]" line59="" line60="    // ----------------------------------------------" line61="    // BLOCK 2: Compute BFS Path" line62="    // ----------------------------------------------" line63="    //% blockId=&quot;FD_computePath&quot; block=&quot;Compute path from row $startR col $startC to row $endR col $endC&quot;" line64="    export function computePath(startR: number, startC: number, endR: number, endC: number): void {" line65="        let rows = grid.length" line66="        if (rows === 0) {" line67="            console.log(&quot;Grid is empty, call initGrid first&quot;)" line68="            return" line69="        }" line70="        let cols = grid[0].length" line71="" line72="        // visited array" line73="        let visited: boolean[][] = []" line74="        for (let i = 0; i &lt; rows; i++) {" line75="            visited.push([])" line76="            for (let j = 0; j &lt; cols; j++) {" line77="                visited[i][j] = false" line78="            }" line79="        }" line80="" line81="        // cameFrom to reconstruct the path" line82="        let cameFrom: { [key: string]: string } = {}" line83="" line84="        // BFS queue using two pointers (no shift usage)" line85="        let queue: string[] = []" line86="        let front = 0 // index of next item" line87="" line88="        // Start" line89="        let startPos = posToString(startR, startC)" line90="        queue.push(startPos)" line91="        visited[startR][startC] = true" line92="" line93="        let found = false" line94="        while (front &lt; queue.length) {" line95="            let currentPosStr = queue[front]" line96="            front++" line97="            let currentRC = stringToPos(currentPosStr)" line98="            let cr = currentRC[0]" line99="            let cc2 = currentRC[1]" line100="" line101="            // Check if we've reached the end" line102="            if (cr === endR &amp;&amp; cc2 === endC) {" line103="                found = true" line104="                break" line105="            }" line106="" line107="            // Explore neighbors" line108="            for (let d = 0; d &lt; directions.length; d++) {" line109="                let rr2 = cr + directions[d][0]" line110="                let cc22 = cc2 + directions[d][1]" line111="                if (rr2 &gt;= 0 &amp;&amp; rr2 &lt; rows &amp;&amp; cc22 &gt;= 0 &amp;&amp; cc22 &lt; cols) {" line112="                    if (grid[rr2][cc22] !== 9 &amp;&amp; !visited[rr2][cc22]) {" line113="                        visited[rr2][cc22] = true" line114="                        let neighborStr = posToString(rr2, cc22)" line115="                        cameFrom[neighborStr] = currentPosStr" line116="                        queue.push(neighborStr)" line117="                    }" line118="                }" line119="            }" line120="        }" line121="" line122="        // Reconstruct path if found" line123="        path = []" line124="        if (found) {" line125="            let endPos = posToString(endR, endC)" line126="            let node = endPos" line127="            // Instead of &quot;while (node in cameFrom)&quot;, do a simpler check:" line128="            while (cameFrom[node]) {" line129="                path.push(node)" line130="                node = cameFrom[node]" line131="            }" line132="            // Add start" line133="            path.push(startPos)" line134="            // Reverse" line135="            let reversed: string[] = []" line136="            for (let k = path.length - 1; k &gt;= 0; k--) {" line137="                reversed.push(path[k])" line138="            }" line139="            path = reversed" line140="            console.log(&quot;Path found with BFS. Steps: &quot; + path.length)" line141="        } else {" line142="            console.log(&quot;No path found with BFS.&quot;)" line143="        }" line144="    }" line145="" line146="    // ----------------------------------------------" line147="    // BLOCK 3: Move Robot Along the Path" line148="    // ----------------------------------------------" line149="    //% blockId=&quot;FD_moveRobot&quot; block=&quot;Move robot along path&quot;" line150="    export function moveRobot(): void {" line151="        if (path.length &lt; 2) {" line152="            console.log(&quot;Path is too short or not computed.&quot;)" line153="            return" line154="        }" line155="" line156="        // Start facing &quot;down&quot; for example" line157="        //  (rowDelta, colDelta)" line158="        let currentDir: [number, number] = [1, 0]" line159="" line160="        for (let l = 0; l &lt; path.length - 1; l++) {" line161="            let thisPos = stringToPos(path[l])" line162="            let nextPos = stringToPos(path[l + 1])" line163="" line164="            let moveDir: [number, number] = [" line165="                nextPos[0] - thisPos[0]," line166="                nextPos[1] - thisPos[1]" line167="            ]" line168="" line169="            // If moveDir != currentDir, we turn" line170="            if (moveDir[0] !== currentDir[0] || moveDir[1] !== currentDir[1]) {" line171="                // naive approach to guess left vs right turn" line172="                if (" line173="                    (currentDir[0] === 1 &amp;&amp; moveDir[1] === 1) ||" line174="                    (currentDir[1] === 1 &amp;&amp; moveDir[0] === -1) ||" line175="                    (currentDir[0] === -1 &amp;&amp; moveDir[1] === -1) ||" line176="                    (currentDir[1] === -1 &amp;&amp; moveDir[0] === 1)" line177="                ) {" line178="                    turnRight()" line179="                } else {" line180="                    turnLeft()" line181="                }" line182="                currentDir = moveDir" line183="            }" line184="" line185="            // move forward" line186="            moveForward()" line187="        }" line188="" line189="        console.log(&quot;Path movement complete.&quot;)" line190="    }" line191="}" numlines="192"></mutation></block></statement></block></xml>